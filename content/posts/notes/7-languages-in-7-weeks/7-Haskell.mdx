---
title: è¯»ã€Š7 å‘¨ 7 è¯­è¨€ã€‹- Haskell
slug: notes-of-7-languages-in-7-weeks-haskell
date: 2020-04-11
description: ã€Š7 å‘¨ 7 è¯­è¨€ã€‹è¯»ä¹¦ç¬”è®°
tags:
  - Note
  - 7 Languages in 7 Weeks
---

> çº¯å‡½æ•°å¼
>
> æƒ°æ€§å¤„ç†
>
> å¼ºç±»å‹é™æ€ç±»å‹
>
> ä¸ä¼šäº§ç”Ÿå‰¯ä½œç”¨ï¼Œå¯ä»¥è¿”å›ä¸€ä¸ªå‰¯ä½œç”¨å¹¶è¢«å»¶è¿Ÿæ‰§è¡Œ

å®‰è£…ä½¿ç”¨ stackï¼Œç„¶åæ¢æˆæ¸…åæºï¼ŒIDE ç”¨ VSCode + HIE

```haskell
0.1 + 0.2
-- 0.30000000000000004
4 * (2.0 + 1)
-- 12
"hello" ++ " world"
-- "hello world"
['a', 'b']
-- "ab"
if 5 == 5 then "true" else "false"
-- "true"
if (1) then "true" else "false"
-- error å¼ºç±»å‹
"one" + 1
-- error

:set +t -- æ‰“å¼€ t æŸ¥çœ‹ç±»å‹
4
-- 4
-- it :: Num p => p
:t 4 -- :t æŸ¥çœ‹ç±»å‹
-- it :: Num p => p
```

å‡½æ•°

```haskell
module Throwaway where

double x = x * 2 -- è‡ªåŠ¨ç±»å‹æ¨æ–­ double :: Num a => a -> a
-- a æ˜¯ä¸€ä¸ªç±»å‹å˜é‡ï¼Œé€šè¿‡ä¼ å…¥å‚æ•°æ¨æ–­å‡ºç±»å‹ aï¼Œä¹‹åè¿”å›ä¹Ÿæ˜¯ a ç±»å‹
```

```haskell
module Throwaway where

double :: Integer -> Integer
double x = x * 2 -- double 2.0 -- error
```

é€’å½’

```haskell
let fact x = if x == 0 then 1 else fact (x - 1) * x -- fact :: (Eq p, Num p) => p -> p
```

æ¨¡å¼åŒ¹é…

```haskell
factorial :: Integer -> Integer
factorial 0 = 1
factorial x = x * factorial (x - 1)
```

å“¨å…µè¡¨è¾¾å¼

```haskell
factorial :: Integer -> Integer
factorial x
  | x > 1 = x * factorial (x - 1)
  | otherwise = 1
```

å…ƒç»„

```haskell
fibTuple :: (Integer, Integer, Integer) -> (Integer, Integer, Integer)
fibTuple (x, y, 0) = (x, y, 0)
fibTuple (x, y, index) = fibTuple (y, x + y, index - 1)

fibResult :: (Integer, Integer, Integer) -> Integer
fibResult (x, y, z) = x

fib :: Integer -> Integer
fib x = fibResult (fibTuple (0, 1, x))
```

å…ƒç»„å’Œç»„åˆ

```haskell
let second list = head (tail list) -- let æ˜¯å±€éƒ¨å®šä¹‰
let second = head . tail -- compose ç®€å†™
```

```haskell
fibNextPair :: (Integer, Integer) -> (Integer, Integer)
fibNextPair (x, y) = (y, x + y)

fibNthPair :: Integer -> (Integer, Integer)
fibNthPair 1 = (1, 1)
fibNthPair n = fibNextPair (fibNthPair (n - 1))

fib :: Integer -> Integer
fib = fst . fibNthPair -- fib n = fst (fibNthPair n)
```

```haskell
let h:t = [1, 2, 3, 4] -- h = 1, t = [2, 3, 4]

size [] = 0
size (h:t) = 1 + size t
-- size "hello world" -> 11

prod [] = 1
prod (h:t) = h * prod t

-- zip ['a', 'c'] ['b', 'd'] -> [('a', 'b'), ('c', 'd')]
```

ç”Ÿæˆåˆ—è¡¨

```haskell
1:[2, 3] -- [1, 2, 3]
[1]:[2, 3] -- error
[1]:[[2], [3, 4]] -- [[1], [2], [3, 4]]

allEven :: [Integer] -> [Integer]
allEven [] = []
allEven (h:t) = if even h then h:allEven t else allEven t
-- allEven [1, 2, 3] -> [2]
```

```haskell
[1 .. 2] -- [1, 2]
[1 .. 4] -- [1, 2, 3, 4]
[10, 4] -- []
[10, 9.5 .. 4] -- [10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5, 4.0]

take 5 [1 .. ] -- [1, 2, 3, 4, 5]
take 5 [0, 3 .. ] -- [0, 3, 6, 9, 12]
```

```haskell
[x * 2 | x <- [1, 2, 3]] -- [2, 4, 6]
[(y, x) | (x, y) <- [(1, 2), (2, 3)]] -- [(2, 1), (3, 2)]

let crew = ["Lj", "Hgk"]
[(a, b) | a <- crew, b <- crew, a /= b]
-- [("Lj","Hgk"),("Hgk","Lj")]
```

é«˜é˜¶å‡½æ•°

```haskell
module Throwaway where
  squareAll list = map square list
    where square x = x * x
-- squareAll [1, 2, 3] -> [1, 4, 9]

map (\x -> x * x) [1, 2, 3]
-- [1, 4, 9]

map (+ 1) [1, 2, 3] -- (+ 1) æ˜¯åå‡½æ•°
-- [2, 3, 4]

filter odd [1, 2, 3, 4, 5]
-- [1, 3, 5]

-- foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldl (\cur acc -> acc + cur) 0 [1 .. 10] -- fold left
-- 55

-- foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
foldl1 (+) [1 .. 10]
-- 55
```

æŸ¯é‡ŒåŒ–

```haskell
let prod x y = x * y
let double = prod 2
let triple = prod 3
```

æƒ°æ€§æ±‚å€¼

```haskell
myRange start step = start:(myRange (start + step) step)
myRange 1 1 -- [1, 2, 3, ............]
take 5 (myRange 10 2) -- [10, 12, 14, 16, 18]
```

```haskell
lazyFib x y = x:(lazyFib y (x + y))
fib = lazyFib 1 1
fibNth n = head (drop (n - 1) (take (n) fib))

take 5 (lazyFib 1 1) -- [1, 1, 2, 3, 5]
take 5 fib -- [1, 1, 2, 3, 5]
take 5 (drop 200 fib) -- [453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705]
fibNth 9 -- 34
take 5 (zipWith (+) fib (drop 1 fib)) -- [2, 3, 5, 8, 13]
take 5 (map (*2) [1 ..]) -- [2, 4, 6, 8, 10]
take 5 (map ((* 2) . (* 5)) fib) -- [10, 10, 20, 30, 50]
```

ç±»å‹

```haskell
'a' -- it :: Char
"abc" -- it :: [Char]
"abc" == ['a', 'b', 'c']
-- True
-- it :: Bool
```

```haskell:title=PlayCard.hs
module PlayCard where

-- è‡ªå®šä¹‰ç±»å‹
data Suit = Spades | Hearts deriving (Show) -- ç»§æ‰¿ Show å‡½æ•°
data Rank = Ten | Jack | Queen | King | Ace deriving (Show)
type Card = (Rank, Suit)
type Hand = [Card]

value :: Rank -> Integer
value Ten = 1
value Jack = 2
value Queen = 3
value King = 4
value Ace = 5

cardValue :: Card -> Integer
cardValue (rank, suit) = value rank
```

```haskell
-- èŒƒå‹
backwards :: [a] -> [a] -- ä¸æ­¢æ˜¯ Hand -> Hand
backwards [] = []
backwards (h:t) = backwards t ++ [h]
```

```haskell
data Triplet a = Trio a a a deriving (Show)
:t Trio 'a' 'b' 'c' -- it :: Triplet Char
```

```haskell
-- é€’å½’ç±»å‹
data Tree a = Children [Tree a] | Leaf a deriving (Show)
depth (Leaf _) = 1
depth (Children c) = 1 + maximum (map depth c)

let tree = Children [Leaf 1, Children [Leaf 2, Leaf 3]]
-- Children [Leaf 1, Children [Leaf 2, Leaf 3]]
-- it :: Num a => Tree a

-- æ¨¡å¼åŒ¹é…
let (Children ch) = tree
-- ch -> [Leaf 1,Children [Leaf 2,Leaf 3]]

depth tree -- 3
```

```haskell
class Eq a where
  (==), (/=) :: a -> a -> Bool
  -- æœ€å°å®Œæ•´å®šä¹‰
  -- (==) æˆ– (/=)
  x /= y   = not (x == y)
  x == y   = not (x /= y)

-- hs ä¸­ Eq ç±»çš„å®šä¹‰
```

## ğŸ¤© monad

[Haskell/Understanding monads](https://en.wikibooks.org/wiki/Haskell/Understanding_monads)

å¤„ç† I / O

```haskell
tryIo = do  putStr "Enter your name: " ;
            line <- getLine ;
            let { backwards = reverse line } ;
            return ("Hello. Your name backwards is " ++ backwards)
```

Maybe

```haskell
case (html doc) of
  Nothing -> Nothing
  Just x  -> case body x of
               Nothing -> Nothing
               Just y  -> paragraph 2 y
```

## feeling

ç±»å‹ç³»ç»Ÿ

çº¯
