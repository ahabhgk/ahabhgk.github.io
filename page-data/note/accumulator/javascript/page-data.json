{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-page-query-tsx","path":"/note/accumulator/javascript","result":{"data":{"page":{"__typename":"MdxPage","title":"JavaScript","slug":"/note/accumulator/javascript","excerpt":"参考 工业聚：100 行代码实现 Promises/A+ 规范","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript\",\n  \"slug\": \"/note/accumulator/javascript\",\n  \"date\": \"2020-05-14T00:00:00.000Z\",\n  \"author\": \"ahabhgk\",\n  \"description\": \"JavaScript\",\n  \"tags\": [\"Note\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"\\u53C2\\u8003\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://zhuanlan.zhihu.com/p/83965949\"\n  }), \"\\u5DE5\\u4E1A\\u805A\\uFF1A100 \\u884C\\u4EE3\\u7801\\u5B9E\\u73B0 Promises/A+ \\u89C4\\u8303\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const isFunction = obj => typeof obj === 'function'\\nconst isObject = obj => !!(obj && typeof obj === 'object') // null \\u7684\\u60C5\\u51B5\\nconst isThenable = obj => (isFunction(obj) || isObject(obj)) && 'then' in obj && isFunction(obj.then)\\nconst isPromise = promise => promise instanceof Promise\\n\\nconst PENDING = 'pending'\\nconst FULFILLED = 'fulfilled'\\nconst REJECTED = 'rejected'\\n\\nclass Promise {\\n  constructor(fn) {\\n    this.status = PENDING\\n    this.value = undefined\\n    this.reason = undefined\\n    this.onFulfilledCallbacks = []\\n    this.onRejectedCallbacks = []\\n    function resolve(value) {\\n      if (this.status !== PENDING)\\n        return\\n      setTimeout(() => {\\n        this.status = FULFILLED\\n        this.value = value\\n        this.onFulfilledCallbacks.forEach(cb => cb(this.value))\\n      }, 0)\\n    }\\n    function reject(reason) {\\n      if (this.status !== PENDING)\\n        return\\n      setTimeout(() => {\\n        this.status = REJECTED\\n        this.reason = reason\\n        this.onRejectedCallbacks.forEach(cb => cb(this.reason))\\n      })\\n    }\\n    try {\\n      fn(resolve, reject)\\n    } catch (e) {\\n      reject(e)\\n    }\\n  }\\n\\n  then(onFulfilled, onRejected) {\\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value\\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }\\n    return bridgePromise = new Promise((resolve, reject) => {\\n      if (this.status === FULFILLED) {\\n        setTimeout(() => {\\n          try {\\n            let result = onFulfilled(this.value)\\n            resolvePromise(bridgePromise, result, resolve, reject)\\n          } catch (e) {\\n            reject(e)\\n          }\\n        }, 0)\\n      } else if (this.status === REJECTED) {\\n        setTimeout(() => {\\n          try {\\n            let result = onRejected(this.reason)\\n            resolvePromise(bridgePromise, result, resolve, reject)\\n          } catch (e) {\\n            reject(e)\\n          }\\n        }, 0)\\n      } else if (this.status === PENDING) {\\n        this.onFulfilledCallbacks.push(() => {\\n          try {\\n            let result = onFulfilled(this.value)\\n            resolvePromise(bridgePromise, result, resolve, reject)\\n          } catch (e) {\\n            reject(e)\\n          }\\n        })\\n        this.onRejectedCallbacks.push(() => {\\n          try {\\n            let result = onRejected(this.reason)\\n            resolvePromise(bridgePromise, result, resolve, reject)\\n          } catch (e) {\\n            reject(e)\\n          }\\n        })\\n      }\\n    })\\n  }\\n\\n  catch(onRejected) {\\n    return this.then(null, onRejected)\\n  }\\n\\n  static resolve(p) {\\n    if (isPromise(p)) return p\\n    return new Promise((resolve, reject) => {\\n      if (isThenable(p)) p.then(resolve, reject)\\n      else resolve(p)\\n    })\\n  }\\n\\n  static reject(p) {\\n    return new Promise((_, reject) => reject(p))\\n  }\\n\\n  static all(promises) {\\n    return new Promise((resolve, reject) => {\\n      let values = []\\n      let count = 0\\n      function handle(value, index) {\\n        values[index] = value\\n        if (++count === promises.length) resolve(values)\\n      }\\n      // p \\u53EF\\u80FD\\u4E0D\\u662F Promise\\uFF0C\\u6240\\u4EE5\\u7528 Promise.resolve \\u5305\\u4E00\\u4E0B\\n      promises.forEach((p, i) => Promise.resolve(p).then(value => handle(value, i), reject))\\n    })\\n  }\\n\\n  static race(promises) {\\n    return new Promise((resolve, reject) => {\\n      promises.forEach(p => Promise.resolve(p).then(resolve, reject))\\n    })\\n  }\\n\\n  static allSettled(promises) {\\n    return new Promise((resolve) => {\\n      let results = []\\n      let count = 0\\n      function handle(result, index) {\\n        results[index] = result\\n        if (++count === promises.length) resolve(results)\\n      }\\n      promises.forEach((p, i) => Promise.resolve(p).then(\\n        value => handle({ status: 'fulfilled', value }, i),\\n        reason => handle({ status: 'rejected', reason }, i),\\n      ))\\n    })\\n  }\\n}\\n\\nfunction resolvePromise(bridgePromise, result, resolve, reject) {\\n  if (bridgePromise === result) {\\n    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))\\n  }\\n  if (isPromise(result)) {\\n    if (result.status === PENDING) {\\n      result.then(y => resolvePromise(bridgePromise, y, resolve, reject), reject)\\n    } else {\\n      result.then(resolve, reject)\\n    }\\n  } else if (isThenable(result)) {\\n    result.then(y => resolvePromise(bridgePromise, y, resolve, reject), reject)\\n  } else {\\n    resolve(result)\\n  }\\n}\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/note/accumulator/javascript"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}