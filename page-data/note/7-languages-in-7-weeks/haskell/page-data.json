{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-page-query-tsx","path":"/note/7-languages-in-7-weeks/haskell","result":{"data":{"page":{"__typename":"MdxPage","title":"Haskell","slug":"/note/7-languages-in-7-weeks/haskell","excerpt":"纯函数式 惰性处理 强类型静态类型 不会产生副作用，可以返回一个副作用并被延迟执行 安装使用 stack，然后换成清华源，IDE 用 VSCode + HIE 函数 递归 模式匹配 哨兵表达式 元组 元组和组合 生成列表 高阶函数 柯里化 惰性求值 类型 🤩 monad…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Haskell\",\n  \"slug\": \"/note/7-languages-in-7-weeks/haskell\",\n  \"date\": \"2020-04-11T00:00:00.000Z\",\n  \"description\": \"《7 周 7 语言》读书笔记\",\n  \"tags\": [\"Note\", \"7 Languages in 7 Weeks\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u7EAF\\u51FD\\u6570\\u5F0F\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u60F0\\u6027\\u5904\\u7406\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u5F3A\\u7C7B\\u578B\\u9759\\u6001\\u7C7B\\u578B\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u4E0D\\u4F1A\\u4EA7\\u751F\\u526F\\u4F5C\\u7528\\uFF0C\\u53EF\\u4EE5\\u8FD4\\u56DE\\u4E00\\u4E2A\\u526F\\u4F5C\\u7528\\u5E76\\u88AB\\u5EF6\\u8FDF\\u6267\\u884C\")), mdx(\"p\", null, \"\\u5B89\\u88C5\\u4F7F\\u7528 stack\\uFF0C\\u7136\\u540E\\u6362\\u6210\\u6E05\\u534E\\u6E90\\uFF0CIDE \\u7528 VSCode + HIE\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"0.1 + 0.2\\n-- 0.30000000000000004\\n4 * (2.0 + 1)\\n-- 12\\n\\\"hello\\\" ++ \\\" world\\\"\\n-- \\\"hello world\\\"\\n['a', 'b']\\n-- \\\"ab\\\"\\nif 5 == 5 then \\\"true\\\" else \\\"false\\\"\\n-- \\\"true\\\"\\nif (1) then \\\"true\\\" else \\\"false\\\"\\n-- error \\u5F3A\\u7C7B\\u578B\\n\\\"one\\\" + 1\\n-- error\\n\\n:set +t -- \\u6253\\u5F00 t \\u67E5\\u770B\\u7C7B\\u578B\\n4\\n-- 4\\n-- it :: Num p => p\\n:t 4 -- :t \\u67E5\\u770B\\u7C7B\\u578B\\n-- it :: Num p => p\\n\")), mdx(\"p\", null, \"\\u51FD\\u6570\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"module Throwaway where\\n\\ndouble x = x * 2 -- \\u81EA\\u52A8\\u7C7B\\u578B\\u63A8\\u65AD double :: Num a => a -> a\\n-- a \\u662F\\u4E00\\u4E2A\\u7C7B\\u578B\\u53D8\\u91CF\\uFF0C\\u901A\\u8FC7\\u4F20\\u5165\\u53C2\\u6570\\u63A8\\u65AD\\u51FA\\u7C7B\\u578B a\\uFF0C\\u4E4B\\u540E\\u8FD4\\u56DE\\u4E5F\\u662F a \\u7C7B\\u578B\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"module Throwaway where\\n\\ndouble :: Integer -> Integer\\ndouble x = x * 2 -- double 2.0 -- error\\n\")), mdx(\"p\", null, \"\\u9012\\u5F52\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"let fact x = if x == 0 then 1 else fact (x - 1) * x -- fact :: (Eq p, Num p) => p -> p\\n\")), mdx(\"p\", null, \"\\u6A21\\u5F0F\\u5339\\u914D\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"factorial :: Integer -> Integer\\nfactorial 0 = 1\\nfactorial x = x * factorial (x - 1)\\n\")), mdx(\"p\", null, \"\\u54E8\\u5175\\u8868\\u8FBE\\u5F0F\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"factorial :: Integer -> Integer\\nfactorial x\\n  | x > 1 = x * factorial (x - 1)\\n  | otherwise = 1\\n\")), mdx(\"p\", null, \"\\u5143\\u7EC4\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"fibTuple :: (Integer, Integer, Integer) -> (Integer, Integer, Integer)\\nfibTuple (x, y, 0) = (x, y, 0)\\nfibTuple (x, y, index) = fibTuple (y, x + y, index - 1)\\n\\nfibResult :: (Integer, Integer, Integer) -> Integer\\nfibResult (x, y, z) = x\\n\\nfib :: Integer -> Integer\\nfib x = fibResult (fibTuple (0, 1, x))\\n\")), mdx(\"p\", null, \"\\u5143\\u7EC4\\u548C\\u7EC4\\u5408\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"let second list = head (tail list) -- let \\u662F\\u5C40\\u90E8\\u5B9A\\u4E49\\nlet second = head . tail -- compose \\u7B80\\u5199\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"fibNextPair :: (Integer, Integer) -> (Integer, Integer)\\nfibNextPair (x, y) = (y, x + y)\\n\\nfibNthPair :: Integer -> (Integer, Integer)\\nfibNthPair 1 = (1, 1)\\nfibNthPair n = fibNextPair (fibNthPair (n - 1))\\n\\nfib :: Integer -> Integer\\nfib = fst . fibNthPair -- fib n = fst (fibNthPair n)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"let h:t = [1, 2, 3, 4] -- h = 1, t = [2, 3, 4]\\n\\nsize [] = 0\\nsize (h:t) = 1 + size t\\n-- size \\\"hello world\\\" -> 11\\n\\nprod [] = 1\\nprod (h:t) = h * prod t\\n\\n-- zip ['a', 'c'] ['b', 'd'] -> [('a', 'b'), ('c', 'd')]\\n\")), mdx(\"p\", null, \"\\u751F\\u6210\\u5217\\u8868\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"1:[2, 3] -- [1, 2, 3]\\n[1]:[2, 3] -- error\\n[1]:[[2], [3, 4]] -- [[1], [2], [3, 4]]\\n\\nallEven :: [Integer] -> [Integer]\\nallEven [] = []\\nallEven (h:t) = if even h then h:allEven t else allEven t\\n-- allEven [1, 2, 3] -> [2]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"[1 .. 2] -- [1, 2]\\n[1 .. 4] -- [1, 2, 3, 4]\\n[10, 4] -- []\\n[10, 9.5 .. 4] -- [10.0, 9.5, 9.0, 8.5, 8.0, 7.5, 7.0, 6.5, 6.0, 5.5, 5.0, 4.5, 4.0]\\n\\ntake 5 [1 .. ] -- [1, 2, 3, 4, 5]\\ntake 5 [0, 3 .. ] -- [0, 3, 6, 9, 12]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"[x * 2 | x <- [1, 2, 3]] -- [2, 4, 6]\\n[(y, x) | (x, y) <- [(1, 2), (2, 3)]] -- [(2, 1), (3, 2)]\\n\\nlet crew = [\\\"Lj\\\", \\\"Hgk\\\"]\\n[(a, b) | a <- crew, b <- crew, a /= b]\\n-- [(\\\"Lj\\\",\\\"Hgk\\\"),(\\\"Hgk\\\",\\\"Lj\\\")]\\n\")), mdx(\"p\", null, \"\\u9AD8\\u9636\\u51FD\\u6570\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"module Throwaway where\\n  squareAll list = map square list\\n    where square x = x * x\\n-- squareAll [1, 2, 3] -> [1, 4, 9]\\n\\nmap (\\\\x -> x * x) [1, 2, 3]\\n-- [1, 4, 9]\\n\\nmap (+ 1) [1, 2, 3] -- (+ 1) \\u662F\\u504F\\u51FD\\u6570\\n-- [2, 3, 4]\\n\\nfilter odd [1, 2, 3, 4, 5]\\n-- [1, 3, 5]\\n\\n-- foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b\\nfoldl (\\\\cur acc -> acc + cur) 0 [1 .. 10] -- fold left\\n-- 55\\n\\n-- foldl1 :: Foldable t => (a -> a -> a) -> t a -> a\\nfoldl1 (+) [1 .. 10]\\n-- 55\\n\")), mdx(\"p\", null, \"\\u67EF\\u91CC\\u5316\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"let prod x y = x * y\\nlet double = prod 2\\nlet triple = prod 3\\n\")), mdx(\"p\", null, \"\\u60F0\\u6027\\u6C42\\u503C\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"myRange start step = start:(myRange (start + step) step)\\nmyRange 1 1 -- [1, 2, 3, ............]\\ntake 5 (myRange 10 2) -- [10, 12, 14, 16, 18]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"lazyFib x y = x:(lazyFib y (x + y))\\nfib = lazyFib 1 1\\nfibNth n = head (drop (n - 1) (take (n) fib))\\n\\ntake 5 (lazyFib 1 1) -- [1, 1, 2, 3, 5]\\ntake 5 fib -- [1, 1, 2, 3, 5]\\ntake 5 (drop 200 fib) -- [453973694165307953197296969697410619233826, 734544867157818093234908902110449296423351, 1188518561323126046432205871807859915657177, 1923063428480944139667114773918309212080528, 3111581989804070186099320645726169127737705]\\nfibNth 9 -- 34\\ntake 5 (zipWith (+) fib (drop 1 fib)) -- [2, 3, 5, 8, 13]\\ntake 5 (map (*2) [1 ..]) -- [2, 4, 6, 8, 10]\\ntake 5 (map ((* 2) . (* 5)) fib) -- [10, 10, 20, 30, 50]\\n\")), mdx(\"p\", null, \"\\u7C7B\\u578B\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"'a' -- it :: Char\\n\\\"abc\\\" -- it :: [Char]\\n\\\"abc\\\" == ['a', 'b', 'c']\\n-- True\\n-- it :: Bool\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell:title=PlayCard.hs\"\n  }), \"module PlayCard where\\n\\n-- \\u81EA\\u5B9A\\u4E49\\u7C7B\\u578B\\ndata Suit = Spades | Hearts deriving (Show) -- \\u7EE7\\u627F Show \\u51FD\\u6570\\ndata Rank = Ten | Jack | Queen | King | Ace deriving (Show)\\ntype Card = (Rank, Suit)\\ntype Hand = [Card]\\n\\nvalue :: Rank -> Integer\\nvalue Ten = 1\\nvalue Jack = 2\\nvalue Queen = 3\\nvalue King = 4\\nvalue Ace = 5\\n\\ncardValue :: Card -> Integer\\ncardValue (rank, suit) = value rank\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"-- \\u8303\\u578B\\nbackwards :: [a] -> [a] -- \\u4E0D\\u6B62\\u662F Hand -> Hand\\nbackwards [] = []\\nbackwards (h:t) = backwards t ++ [h]\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"data Triplet a = Trio a a a deriving (Show)\\n:t Trio 'a' 'b' 'c' -- it :: Triplet Char\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"-- \\u9012\\u5F52\\u7C7B\\u578B\\ndata Tree a = Children [Tree a] | Leaf a deriving (Show)\\ndepth (Leaf _) = 1\\ndepth (Children c) = 1 + maximum (map depth c)\\n\\nlet tree = Children [Leaf 1, Children [Leaf 2, Leaf 3]]\\n-- Children [Leaf 1, Children [Leaf 2, Leaf 3]]\\n-- it :: Num a => Tree a\\n\\n-- \\u6A21\\u5F0F\\u5339\\u914D\\nlet (Children ch) = tree\\n-- ch -> [Leaf 1,Children [Leaf 2,Leaf 3]]\\n\\ndepth tree -- 3\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"class Eq a where\\n  (==), (/=) :: a -> a -> Bool\\n  -- \\u6700\\u5C0F\\u5B8C\\u6574\\u5B9A\\u4E49\\n  -- (==) \\u6216 (/=)\\n  x /= y   = not (x == y)\\n  x == y   = not (x /= y)\\n\\n-- hs \\u4E2D Eq \\u7C7B\\u7684\\u5B9A\\u4E49\\n\")), mdx(\"h2\", {\n    \"id\": \"🤩-monad\"\n  }, \"\\uD83E\\uDD29 monad\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikibooks.org/wiki/Haskell/Understanding_monads\"\n  }), \"Haskell/Understanding monads\")), mdx(\"p\", null, \"\\u5904\\u7406 I / O\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"tryIo = do  putStr \\\"Enter your name: \\\" ;\\n            line <- getLine ;\\n            let { backwards = reverse line } ;\\n            return (\\\"Hello. Your name backwards is \\\" ++ backwards)\\n\")), mdx(\"p\", null, \"Maybe\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-haskell\"\n  }), \"case (html doc) of\\n  Nothing -> Nothing\\n  Just x  -> case body x of\\n               Nothing -> Nothing\\n               Just y  -> paragraph 2 y\\n\")), mdx(\"h2\", {\n    \"id\": \"feeling\"\n  }, \"feeling\"), mdx(\"p\", null, \"\\u7C7B\\u578B\\u7CFB\\u7EDF\"), mdx(\"p\", null, \"\\u7EAF\"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/note/7-languages-in-7-weeks/haskell"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}