{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-page-query-tsx","path":"/note/programming-language/part-a","result":{"data":{"page":{"__typename":"MdxPage","title":"Programming Language","slug":"/note/programming-language/part-a","excerpt":"Unit 1: ML Functions, Tuples, Lists, and More Semantics Syntax is just how you write something Semantics is what that something means Type…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Programming Language\",\n  \"slug\": \"/note/programming-language/part-a\",\n  \"date\": \"2020-08-20T00:00:00.000Z\",\n  \"description\": \"《Programming Language》MOOC 笔记\",\n  \"tags\": [\"Note\"]\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", {\n    \"id\": \"unit-1-ml-functions-tuples-lists-and-more\"\n  }, \"Unit 1: ML Functions, Tuples, Lists, and More\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"(* Let's SML! *)\\n\\nval x = 1;\\n(* static env: x: int *)\\n(* dynamic env: x -> 1 *)\\n\\nval y = 2;\\n(* static env: x: int, y: int *)\\n(* dynamic env: x -> 1, y -> 2 *)\\n\\nval z = (x + 1) * (y + 2);\\n(* static env: x: int, y: int, z: int *)\\n(* dynamic env: x -> 1, y -> 2, z -> 8 *)\\n\\nval abs_z = if z < 0 then 0 - z else z; (* bool *) (* int *)\\n(* static env: ..., abs_z: int *)\\n(* dynamic env: ..., abs_z: 8 *)\\n\\nval abs_z_simpler = abs z;\\n\")), mdx(\"p\", null, \"Semantics\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax is just how you write something\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Semantics is what that something means\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking (before program runs)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation (as program runs)\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"For variable bindings:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-check expression and extend static environment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluate expression and extend dynamic environment\")))), mdx(\"p\", null, \"Expression\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking rules\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Produces a type or fails (with a bad error message)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Types so far: int bool unit\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation rules (used only on things that type-check)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Produces a value (or exception or infinite-loop)\")))), mdx(\"p\", null, \"Variables\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"sequence of letters, digits, _, not starting with digit\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Look up type in current static environment\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If not there fail\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Look up value in current dynamic environment\")))), mdx(\"p\", null, \"Less-than\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"e1 + e2 where e1 and e2 are expressions\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If e1 and e2 have type int, then e1 + e2 has type int\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If e1 evaluates to v1 and e2 evaluates to v2, then e1 + e2 evaluates to sum of v1 and v2\")))), mdx(\"p\", null, \"Conditional\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Syntax:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if e1 then e2 else e3. e1, e2 and e3 are expressions\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Type-checking:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"e1 must have type bool, e2 and e3 have type T, the type of entire expression is also T\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Evaluation:\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"evaluate e1 to a value call it v1, if v1 is true, then evaluate e2 and that result is the whole expression's result, else evaluate e3 and that result is the whole exporession's result\")))), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"val x = 0 - 5\\nval y = ~5\\ny = x (* true *)\\n\\n2.0 / 1.0 (* 2.0: real *)\\n2 div 1 (* 2: int *)\\n\")), mdx(\"p\", null, \"Function\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun pow(x : int, y : int) =\\n  if y = 0\\n  then 1\\n  else x * pow(x, y - 1)\\n(* val pow = fn : int * int -> int *)\\n\\nfun cube(x) =\\n  pow(x, 3)\\n(* val cube = fn : int -> int *)\\n\\nval x = pow(3, 4)\\nval y = cube(3)\\n\")), mdx(\"p\", null, \"Pair\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun swap(pr : int * bool) =\\n  (#2 pr, #1 pr)\\n(* val swap = fn : int * bool -> bool * int *)\\n\\nfun sum_two_pairs(pr1: int * int, pr2 : int * int) =\\n  (#1 pr1) + (#2 pr1) + (#1 pr2) + (#2 pr2)\\n(* val sum_two_pair = fn : (int * int) * (int * int) -> int *)\\n\\nfun div_mod(x : int, y : int) =\\n  (x div y, x mod y)\\n(* val div_mod = fn : int * int -> int * int *)\\n\\nfun sort_pair(pr : int * int) =\\n  if (#1 pr) < (#2 pr)\\n  then pr\\n  else (#2 pr, #1 pr)\\n\")), mdx(\"p\", null, \"Tuples: fixed \\\"number of pieces\\\" that may have different types\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"val x = (7, (true, 9), (1, 2, 3)) (* int * (bool * int) * (int * int * int) *)\\nval y = #1 (#2 x) (* bool *)\\nval z = #3 x (* int * int * int *)\\n\")), mdx(\"p\", null, \"Lists: have any number of elements, all list elements have the same type\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"null e\"), \" evaluates to true if and only if e evaluates to []\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if e evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[v1, v2, ..., vn]\"), \" then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"hd e\"), \" evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"v1\"), \" (raise exception if e evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[]\"), \")\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if e evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[v1, v2, ..., vn]\"), \" then \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"tl e\"), \" evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[v2, ..., vn]\"), \" (raise exception if e evaluates to \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[]\"), \")\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"[] (* 'a list (type a list) *)\\n[1, 2, 3] (* int list *)\\n[true, false, false] (* bool list *)\\n\\ntrue::[] (* bool list *)\\n5::[6, 7] (* [5, 6, 7] int list *)\\n[1]::[[2, 3], [4, 5]] (* int list list *)\\n\\n(* val null = fn : 'a list -> bool *)\\nnull [1, 2] (* false *)\\nnull [] (* true *)\\n\\n(* val hd = fn : 'a list -> 'a *)\\nhd (tl [1, 2, 3]) (* 2 *)\\n\\n(* val hd = fn : 'a list -> 'a list *)\\ntl (tl (tl [1, 2, 3])) (* [] *)\\ntl (tl (tl (tl [1, 2, 3]))) (* error! *)\\n\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sml\"\n  }), \"fun append (xs, ys) =\\n  if null xs\\n  then ys\\n  else (hd xs) :: append ((tl xs), ys)\\n\\nfun map (f, xs) =\\n  if null xs\\n  then []\\n  else (f (hd xs)) :: (map (f, (tl xs)))\\n\\nfun firsts2 (xs : (int * int) list) =\\n  map (fn (x) => (#1 x), xs)\\n\\nfun seconds2 (xs : (int * int) list) =\\n  map (fn (x) => (#2 x), xs)\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/note/programming-language/part-a"}},"staticQueryHashes":["318001574","3787687951","3787687951"]}